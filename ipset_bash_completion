#!/bin/bash

# -----------------------------------------------------------------
# Programmable completion code for ipset (netfilter.org)
#
# https://github.com/AllKind/ipset-bash-completion
# https://sourceforge.net/projects/ipset-bashcompl
# -----------------------------------------------------------------

# Copyright (C) 2013 AllKind (AllKind@fastest.cc)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# -----------------------------------------------------------------
# Tested with ipset versions:
# 6.16.1
# -----------------------------------------------------------------
#
# Put it into ~/.bash_completion or /etc/bash_completion.d/
#
# -----------------------------------------------------------------
#
# Version 1.9
#
# -----------------------------------------------------------------


_ipset_bash_default_compl() { # taken from examples - modified by me
# call with the word to be completed as $1
local t
if [[ $1 == \$\(* ]]; then # command substitution
	t=${1#??}
	COMPREPLY=( $(compgen -c -P '$(' $t) )
elif [[ $1 == \$\{* ]]; then # variables with a leading `${'
	t=${1#??}
	COMPREPLY=( $(compgen -v -P '${' -S '}' $t) )
elif [[ $1 == \$* ]]; then # variables with a leading `$'
	t=${1#?}
	COMPREPLY=( $(compgen -v -P '$' $t ) )
elif [[ "$1" == *@* ]]; then # hostname
	t=${1#*@}
	COMPREPLY=( $( compgen -A hostname $t ) )
elif [[ $1 == *[*?[]* ]]; then # sh-style glob pattern
	COMPREPLY=( $( compgen -G "$1" ) )
# ksh-style extended glob pattern - must be complete
elif shopt -q extglob && [[ $1 == *[?*+\!@]\(*\)* ]]; then
	COMPREPLY=( $( compgen -G "$1" ) )
fi
}

_ipset_get_set_type() {
while read n d; do
	[[ $n = Type: ]] && printf '%s\n' $d && break
done < <(ipset -t list "$1" 2>/dev/null)
}

_ipset_get_members() {
local -i in_list=0 no=0
arr_members=()
if [[ $1 = --names-only ]]; then no=1
	shift
fi
while read -r; do
	[[ $REPLY = Members:* ]] && in_list=1 && continue
	((in_list)) || continue
	if ((no)); then
		arr_members[${#arr_members[@]}]="${REPLY%% *}"
	else
		arr_members[${#arr_members[@]}]="$REPLY"
	fi
done < <(ipset list "$1" 2>/dev/null)
}

_ipset_complete() {
shopt -s extglob
local cur prev ips_version str_action str_setname str_filename str_tmp
local -i i=x=y=got_action=action_index=0
local -i ignore_errors=use_file=names_only=headers_only=save_format=res_sort=0
local arr_sets=() arr_types=() arr_members=() arr_unknown_opts=() arr_tmp=()
local arr_opts=(
"-\! -exist"
"-o -output"
"-q -quiet"
"-r -resolve"
"-n -name"
"-t -terse"
"-f -file"
)

# ipset version check 6.x upwards (to v?) is supported
ips_version="$(ipset --version)"
ips_version="${ips_version#ipset v}"
ips_version="${ips_version%%.*}"
[[ $ips_version = +([[:digit:]]) ]] || return 1
((ips_version < 6)) && return 1

COMPREPLY=()
COMP_WORDBREAKS=$' \t\n"\'><=;|&(' # TODO: different solution than permanent setting

# expecting _get_comp_words_by_ref() to exist from bash_completion
_get_comp_words_by_ref cur || return
_get_comp_words_by_ref prev || return

#_DEBUG_IPSET_COMPL=Y
if [[ $_DEBUG_IPSET_COMPL ]]; then
	printf "\nCOMP_WORDBREAKS: <%s>\n" "$COMP_WORDBREAKS"
	printf "COMP_LINE: <%s>\n" "$COMP_LINE"
	printf "COMP_TYPE: <%s>\n" "$COMP_TYPE"
	printf "COMP_POINT: <%s>\n" "$COMP_POINT"
	printf "COMP_KEY: <%s>\n" "$COMP_KEY"
	printf "COMP_CWORD: <%s>\n" "$COMP_CWORD"
	printf "COMP_WORDS:\n"
	printf "<%s>\n" "${COMP_WORDS[@]}"
	printf "cur: <%s> prev: <%s>\n" "$cur" "$prev"
fi

# collect information about used options
for ((i=1; i < ${#COMP_WORDS[@]}; i++)); do
	case "${COMP_WORDS[i]}" in
		@(create|n|add|del|test|destroy|x|list|save|restore|flush|rename|e|swap|w|help|version))
			[[ ${COMP_WORDS[i-1]} = @(-f|-file) ]] && continue # there could be a file named like a command
			if ! ((got_action)); then
				for x in ${!arr_opts[@]}; do
					set -- ${arr_opts[x]}
					[[ ${COMP_WORDS[i+1]} = @($1|$2) ]] && return 0 # sets with names of options 
				done
			fi
			if [[ ${COMP_WORDS[i]} != save ]]; then
				if ! ((got_action)); then got_action=1 str_action=${COMP_WORDS[i]} action_index=$i
					if [[ $str_action = @(create|n|add|del|test|destroy|x|list|save|restore|flush|rename|e|swap|w) ]]; then
						str_setname=${COMP_WORDS[i+1]} # register the set name
					fi
				fi
			else
				if [[ ${COMP_WORDS[i-1]} != @(-o|-output) ]]; then
					if ! ((got_action)); then got_action=1 str_action=${COMP_WORDS[i]} action_index=$i
						if [[ $str_action = @(create|n|add|del|test|destroy|x|list|save|restore|flush|rename|e|swap|w) ]]; then
							str_setname=${COMP_WORDS[i+1]} # register the set name
						fi
					fi
				fi
			fi
		;;
		-\!|-exist) [[ ${COMP_WORDS[i-1]} != @(-f|-file) ]] && ignore_errors=1 ;;
		-f|-file) [[ ${COMP_WORDS[i-1]} != @(-f|-file) ]] && use_file=1 str_filename="${COMP_WORDS[i+1]}" ;;
		-n|-name) [[ ${COMP_WORDS[i-1]} != @(-f|-file) ]] && names_only=1 ;;
		-t|-terse) [[ ${COMP_WORDS[i-1]} != @(-f|-file) ]] && headers_only=1 ;;
		-o|-output)
			if [[ ${COMP_WORDS[i-1]} != @(-f|-file) ]]; then save_format=1
				if [[ $prev = @(-o|-output) ]]; then
					save_format=2 # expecting opt-arg
				elif [[ ${COMP_WORDS[i+1]} = save ]]; then
					save_format=3 # no -n/-t with -o save
				fi
			fi
		;;
		-r|-resolve|-s|-sorted) [[ ${COMP_WORDS[i-1]} != @(-f|-file) ]] && res_sort=1 ;;
		-?*)
			if [[ ${COMP_WORDS[i]#-} != @(q|quiet) ]]; then
				if [[ ${COMP_WORDS[i-1]} != @(-f|-file|\>) || ${COMP_WORDS[i+1]} != \< ]]; then # don't include filenames
					arr_unknown_opts[${#arr_unknown_opts[@]}]="${COMP_WORDS[i]}"
				fi
			fi
		;;
	esac
done

# invalid combination of options
if ((names_only && headers_only)); then
	return 0
elif ((names_only || headers_only)); then
	if ((res_sort || ignore_errors)) || ((save_format == 3)); then
		return 0
	fi
elif ((ignore_errors)); then
	if ((res_sort || save_format)); then
		return 0
	fi
fi

# for help or create, find supported set types and save them into an array
if [[ $str_action = @(help|create|n) ]]; then i=0
	while read -r; do
		[[ $REPLY = "Supported set types:"* ]] && ((!i)) && i=1 && continue
		((i)) || continue
		if [[ $REPLY = *:* ]]; then
			set -- $REPLY
			arr_types[${#arr_types[@]}]="$1"
		fi
	done < <(ipset help)
	for i in ${!arr_types[@]}; do # remove dupe entries
		for ((x=i+1; x < ${#arr_types[@]}; x++)); do
			if [[ ${arr_types[i]} = ${arr_types[x]} ]]; then
				unset arr_types[x]
			fi
		done
	done
fi

case "$cur" in
	-*) # any option is requested
		if ((save_format == 2)); then
			return 0
		fi
		if [[ $str_action = @(create|n) && $prev = $str_setname ]]; then
			return 0 # expecting completion of set types
		fi
		case "$prev" in
			create|n) # -option not expected
				if ((got_action)) && [[ $str_action = $prev ]] && [[ $str_filename != $prev ]]; then
					return 0
				fi
			;;
			add|del|list|test|rename|e|swap|w) # -option not expected
				# check if we have a set beginning with `-'
				if ((got_action)) && [[ $str_action = $prev ]]; then
					arr_sets=( $(ipset list -n ) )
					for x in ${!arr_sets[@]}; do
						if [[ ${arr_sets[x]} = ${cur}* ]]; then
							COMPREPLY=( $( compgen -W '${arr_sets[@]}' -- $cur ) )
							break
						fi
					done
					return 0
				fi
			;;
			\<|\>|-f|-file) # expecting filenames as completion
				compopt -o nospace
				COMPREPLY=( $( compgen -f -- $cur ) )
				return 0
			;;
			-) # interactive mode
				if ((got_action)); then
					if [[ $str_action != @(create|n) ]]; then
						# check if we have a set beginning with `-'
						arr_sets=( $(ipset list -n ) ) i=0
						for x in ${!arr_sets[@]}; do
							[[ ${arr_sets[x]} = - ]] && i=1 && break
						done
						((i)) || return 0
					else
						return 0
					fi
				else
					return 0
				fi
			;;
		esac
		if ((got_action)); then
			case "$str_action" in
				create|n|add|del)
					COMPREPLY=( $( compgen -W '-\! -exist -q -quiet' -- $cur ) )
					for ((i=2; i < ${#COMP_WORDS[@]}; i++)); do
						if [[ $str_action = ${COMP_WORDS[i]} && ${COMP_WORDS[i+2]} = -* ]]; then
							COMPREPLY=() # option not expected, want command value
							return 0
						elif [[ $str_action = @(create|n) ]]; then
							if [[ $prev = @(timeout|range|maxelem|family|hashsize|size|netmask) ]]; then
								COMPREPLY=() # option not expected, want command value
								return 0
							fi
						elif [[ $str_action = add ]]; then
							if [[ $prev = @(timeout|before|after) ]]; then
								COMPREPLY=() # option not expected, want command value
								return 0
							fi
						elif [[ $str_action = del ]]; then
							if [[ $prev = @(before|after) ]]; then
								COMPREPLY=() # option not expected, want command value
								return 0
							fi
						elif [[ ${COMP_WORDS[i]} = @(timeout|maxelem|hashsize|size) && ${COMP_WORDS[x+1]} != @(+([[:digit:]])|0x+([[:xdigit:]])) ]]
						then return 0 # option argument validation
						elif [[ ${COMP_WORDS[i]} = range && ${COMP_WORDS[x+1]} != *-* ]]
						then return 0 # option argument validation
						elif [[ ${COMP_WORDS[i]} = family && ${COMP_WORDS[x+1]} != inet?(6) ]]
						then return 0 # option argument validation
						fi
					done
				;;
				destroy|x|flush) COMPREPLY=( $( compgen -W '-q -quiet' -- $cur ) ) ;;
				list)
					if ((names_only || headers_only)); then
						COMPREPLY=( $( compgen -W '-f -file -o -output -q -quiet' -- $cur ) )
					elif ((res_sort)); then
						COMPREPLY=( $( compgen -W '-f -file -o -output -q -quiet -r -resolve -s -sorted' -- $cur ) )
					elif ((save_format == 1)); then
						COMPREPLY=( $( compgen -W '-f -file -q -quiet -r -resolve -s -sorted -t -terse' -- $cur ) )
					elif ((save_format == 3)); then
						COMPREPLY=( $( compgen -W '-f -file -q -quiet -r -resolve -s -sorted' -- $cur ) )
					else
						COMPREPLY=( $( compgen -W '-f -file -n -name -o -output -q -quiet -r -resolve -s -sorted -t -terse' -- $cur ) )
					fi
				;;
				restore) COMPREPLY=( $( compgen -W '-\! -exist -f -file -q -quiet' -- $cur ) ) ;;
				save) COMPREPLY=( $( compgen -W '-f -file -q -quiet' -- $cur ) ) ;;
				rename|e|swap|w|test) COMPREPLY=( $( compgen -W '-q -quiet' -- $cur ) )
					for ((i=1; i < ${#COMP_WORDS[@]}; i++)); do
						if [[ $str_action = ${COMP_WORDS[i]} && ${COMP_WORDS[i+2]} = -* ]]; then
							COMPREPLY=() # option not expected, want command value
							break
						elif [[ $str_action = test ]]; then
							if [[ $prev = @(before|after) ]]; then
								COMPREPLY=() # option not expected, want command value
								return 0
							fi
						fi
					done
				;;
				help|version) COMPREPLY=()
					return 0
				;;
			esac
		else COMPREPLY=( $( compgen -W '- ${arr_opts[@]}' -- $cur ) )
			if ((names_only || headers_only)) && ((save_format == 1)); then
				COMPREPLY=( $( compgen -W '-f -file -q -quiet' -- $cur ) )
			elif ((names_only || headers_only)); then
				COMPREPLY=( $( compgen -W '-f -file -o -output -q -quiet' -- $cur ) )
			elif ((res_sort)); then
				COMPREPLY=( $( compgen -W '-f -file -o -output -q -quiet -r -resolve -s -sorted' -- $cur ) )
			elif ((save_format == 1)); then
				COMPREPLY=( $( compgen -W '-f -file -q -quiet -r -resolve -s -sorted -t -terse' -- $cur ) )
			elif ((save_format == 3)); then
				COMPREPLY=( $( compgen -W '-f -file -q -quiet -r -resolve -s -sorted' -- $cur ) )
			elif ((ignore_errors)); then
				COMPREPLY=( $( compgen -W '-f -file -q -quiet' -- $cur ) )
			elif ((use_file)); then
				COMPREPLY=( $( compgen -W '-\! -exist -n -name -o -output -q -quiet -r -resolve -s -sorted -t -terse' -- $cur ) )
			fi
		fi
	;;
	\<|\>) # redirection operator
		compopt -o nospace
		COMPREPLY=( $( compgen -f ) ) # no $cur, so completion starts without space after redirection
		return 0
	;;
	\$\{*) # variables with a leading `${'
		COMPREPLY=( $(compgen -v -P '${' -S '}' ${cur#??}) )
		return 0
	;;
	\$*) # variables with a leading `$'
		COMPREPLY=( $(compgen -v -P '$' ${cur#?} ) )
		return 0
	;;
	*) # not an option
		if ((got_action)); then
			if [[ $str_action = @(create|n) && $prev = $str_setname ]]
			then
				COMPREPLY=( $( compgen -W '${arr_types[@]}' -- $cur ) )
				return 0
			fi
			arr_sets=( $(ipset list -n ) )
		else
			COMPREPLY=( $( compgen -W 'create n add del test destroy x list save restore flush rename e swap w help version' -- $cur ) )
		fi
		case "$prev" in # depend on previous option
			-)
				if ((got_action)); then
					case "$str_action" in
						create|n) # if users wants to create a set named `-'
							COMPREPLY=( $( compgen -W '${arr_types[@]}' -- $cur ) )
							return 0
							;;
					esac
				fi
			;;
			restore)
			   	if ((got_action)) && [[ $str_action = $prev ]]; then
					if [[ $str_filename ]]; then
						COMPREPLY=() # don't show redirector if we have option -f
					else
						COMPREPLY=( \< )
					fi
					return 0
				fi
			;;
			create|n|version) COMPREPLY=()
				return 0
			;;
			add|del|destroy|x|rename|e|swap|w|test)
			   	if ((got_action)) && [[ $str_action = $prev ]]; then
					COMPREPLY=( $( compgen -W '${arr_sets[@]}' -- $cur ) )
					return 0
				fi
			;;
			save)
			   	if ((got_action)) && [[ $str_action = $prev ]]; then
					if [[ $str_action = save ]]; then
						COMPREPLY=( $( compgen -W '${arr_sets[@]}' -- $cur ) ) 
						return 0
					else
						if ((save_format == 3 && ! got_action)); then
							COMPREPLY=( $( compgen -W 'list' -- $cur ) )
							return 0
						fi
					fi
				fi
			;;
			list)
			   	if ((got_action)) && [[ $str_action = $prev ]]; then
					COMPREPLY=( $( compgen -W '${arr_sets[@]}' -- $cur ) )
					return 0
				fi
			;;
			help)
			   	if ((got_action)) && [[ $str_action = $prev ]]; then
					COMPREPLY=( $( compgen -W '${arr_types[@]}' -- $cur ) )
					return 0
				fi
			;;
			-o|-output)
				# make sure it's not a filename named -o or -output
				if [[ $str_filename != $prev ]]; then
					if ((names_only || headers_only)); then
						COMPREPLY=( $( compgen -W 'plain xml' -- $cur ) )
					else
						COMPREPLY=( $( compgen -W 'plain save xml' -- $cur ) )
					fi
					return 0
				fi
			;;
			-f|-file|\<|\>) compopt -o nospace
				COMPREPLY=( $( compgen -f -- $cur ) )
				return 0
			;;
			*)
				if ((got_action)); then
					COMPREPLY=( $( compgen -W '${arr_sets[@]}' -- $cur ) )
					for ((i=1; i < ${#COMP_WORDS[@]}; i++)); do
						if [[ ${COMP_WORDS[i]} = $str_action ]]; then
							case "${COMP_WORDS[i]}" in
								add) COMPREPLY=() # only list sets after the action command
									str_tmp=$(_ipset_get_set_type "${COMP_WORDS[i+1]}")
									if [[ ${COMP_WORDS[i+1]} = $prev ]]; then # position after set-name
										case "$str_tmp" in
											list:*) arr_tmp=()
												_ipset_get_members --names-only "${COMP_WORDS[i+1]}"
												for x in ${!arr_sets[@]}; do
													for y in ${!arr_members[@]}; do
														[[ ${arr_sets[x]} = ${arr_members[y]} ]] && continue 2
													done
													arr_tmp[${#arr_tmp[@]}]="${arr_sets[x]}"
												done
												COMPREPLY=( $( compgen -W '${arr_tmp[@]}' -- $cur ) )
											;;
										esac
									elif [[ ${COMP_WORDS[i+2]} = $prev ]]; then # add options
										case "$str_tmp" in
											hash:*net*)
												COMPREPLY=( $( compgen -W 'timeout nomatch' -- $cur ) )
											;;
											hash:*!(net)*|bitmap:*)
												COMPREPLY=( $( compgen -W 'timeout' -- $cur ) )
											;;
											list:*)
												COMPREPLY=( $( compgen -W 'before after timeout' -- $cur ) )
											;;
										esac
									else # add options following
										for ((x=i+3; x < ${#COMP_WORDS[@]}; x++)); do # valide option argument values
											[[ ${COMP_WORDS[x]} = timeout && ${COMP_WORDS[x+1]} != @(+([[:digit:]])|0x+([[:xdigit:]])) ]] && return 0
										done
										case "$str_tmp" in
											hash:*net*)
												if [[ $prev != @(-*|timeout) ]]; then
													COMPREPLY=( $( compgen -W 'timeout nomatch' -- $cur ) )
												fi
											;;
											list:*)
												if [[ $prev = @(before|after) ]]; then
													_ipset_get_members --names-only "${COMP_WORDS[i+1]}"
													COMPREPLY=( $( compgen -W '${arr_members[@]}' -- $cur ) )
												else
													if [[ $prev != @(-*|timeout) ]]; then
														COMPREPLY=( $( compgen -W 'timeout' -- $cur ) )
													fi
												fi
											;;
										esac

									fi
									break
								;;
								create|n) COMPREPLY=()
									if [[ ${COMP_WORDS[i+1]} = $prev ]]; then
										COMPREPLY=( $( compgen -W '${arr_types[@]}' -- $cur ) )
									elif [[ ${COMP_WORDS[i+2]} = $prev ]]; then # create options
										case "$prev" in
											hash:*)
												COMPREPLY=( $( compgen -W 'family hashsize timeout maxelem' -- $cur ) )
											;;
											bitmap:ip)
												COMPREPLY=( $( compgen -W 'range netmask timeout' -- $cur ) )
											;;
											bitmap:!(ip)?*)
												COMPREPLY=( $( compgen -W 'range timeout' -- $cur ) )
											;;
											list:*)
												COMPREPLY=( $( compgen -W 'size timeout' -- $cur ) )
											;;
										esac
									else # create options following
										for ((x=i+3; x < ${#COMP_WORDS[@]}; x++)); do
											case "${COMP_WORDS[x]}" in # validate option argument values
												@(hashsize|timeout|size|maxelem))
													[[ ${COMP_WORDS[x+1]} != @(+([[:digit:]])|0x+([[:xdigit:]])) ]] && return 0
													;;
												family)
													[[ ${COMP_WORDS[x+1]} && ${COMP_WORDS[x+1]} != inet?(6) ]] && return 0
													;;
												range)
													[[ ${COMP_WORDS[x+1]} && ${COMP_WORDS[x+1]} != *-* ]] && return 0
													;;
											esac
										done
										case "${COMP_WORDS[i+2]}" in
											hash:*)
												case "$prev" in
													family)
														COMPREPLY=( $( compgen -W 'inet inet6' -- $cur ) )
														return 0
													;;
													*) if [[ $prev != @(-*|family|hashsize|timeout|maxelem) ]]; then
															COMPREPLY=( $( compgen -W 'family hashsize timeout maxelem' -- $cur ) )
														fi
												esac
											;;
											bitmap:ip)
												if [[ $prev != @(-*|range|netmask|timeout) ]]; then
													COMPREPLY=( $( compgen -W 'range netmask timeout' -- $cur ) )
												fi
											;;
											bitmap:!(ip)?*)
												if [[ $prev != @(-*|range|timeout) ]]; then
													COMPREPLY=( $( compgen -W 'range timeout' -- $cur ) )
												fi
											;;
											list:*)
												if [[ $prev != @(-*|size|timeout) ]]; then
													COMPREPLY=( $( compgen -W 'size timeout' -- $cur ) )
												fi
											;;
										esac
									fi
									break
								;;
								del|test) COMPREPLY=() # complete members
									str_tmp=$(_ipset_get_set_type "${COMP_WORDS[i+1]}")
									_ipset_get_members --names-only "${COMP_WORDS[i+1]}"
									if [[ ${COMP_WORDS[i+1]} = $prev ]]; then # position after set-name
										COMPREPLY=( $( compgen -W '${arr_members[@]}' -- $cur ) )
									elif [[ ${COMP_WORDS[i+2]} = $prev ]]; then # add options
										case "$str_tmp" in
											list:*) COMPREPLY=( $( compgen -W 'before after' -- $cur ) ) ;;
										esac
									else # add options following
										case "$str_tmp" in
											list:*) arr_tmp=()
												if [[ $prev = @(before|after) ]]; then
													case "$prev" in
														before)
															for x in ${!arr_members[@]}; do
																if [[ ${arr_members[x]} = ${COMP_WORDS[i+2]} ]]; then
																	if [[ ${arr_members[x+1]} ]]; then
																		arr_tmp[${#arr_tmp[@]}]=${arr_members[x+1]}
																		break
																	fi
																fi
															done
															;;
														after)
															for x in ${!arr_members[@]}; do
																if [[ ${arr_members[x]} = ${COMP_WORDS[i+2]} ]]; then
																	if ((x>0)) && [[ ${arr_members[x-1]} ]]; then
																		arr_tmp[${#arr_tmp[@]}]=${arr_members[x-1]}
																		break
																	fi
																fi
															done
															;;
													esac
													COMPREPLY=( $( compgen -W '${arr_tmp[@]}' -- $cur ) )
												fi
											;;
										esac
									fi
									break
								;;
								help)
									if [[ ${COMP_WORDS[i+1]} ]]; then 
										COMPREPLY=() # don't go further than showing the set types
										return 0
									fi
									break
								;;
								restore) COMPREPLY=() # not a redirecton
									break
								;;
								swap|w)
									for x in ${!arr_sets[@]}; do
										if [[ ${arr_sets[x]} = ${COMP_WORDS[i+2]} ]]; then
											COMPREPLY=() # only list two sets
											break 2
										fi
									done
									break
								;;
								*)
									for ((y=1; y < ${#COMP_WORDS[@]}; y++)); do
										[[ ${COMP_WORDS[y]} ]] || continue
										for x in ${!arr_sets[@]}; do
											if [[ ${arr_sets[x]} = ${COMP_WORDS[y]} ]]; then
												COMPREPLY=() # list only one set
												break 2
											fi
										done
									done
								;;
							esac
						fi
					done
				else # we don't have the action yet, check options to display appropiate actions
					if ((save_format || names_only || headers_only)); then
						COMPREPLY=( $( compgen -W 'list' -- $cur ) )
						return 0
					elif ((res_sort)); then
						COMPREPLY=( $( compgen -W 'list save' -- $cur ) )
						return 0
					elif ((ignore_errors && use_file)); then
						COMPREPLY=( $( compgen -W 'restore' -- $cur ) )
						return 0
					elif ((ignore_errors)); then
						COMPREPLY=( $( compgen -W 'create n add del restore' -- $cur ) )
						return 0
					elif ((use_file)); then
						COMPREPLY=( $( compgen -W 'list save restore' -- $cur ) )
						return 0
					fi
				fi
			;;
		esac
	;;
esac
if [[ $_DEBUG_IPSET_COMPL ]]; then
	printf "COMPREPLY before dedupe:\n"
	printf "<%s>\n" "${COMPREPLY[@]}"
fi
if ((${#COMPREPLY[@]})); then # post process the reply
	for ((i=1; i < ${#COMP_WORDS[@]}; i++)); do # remove dupe options
		[[ ${COMP_WORDS[i]} = @(""|-) ]] && continue
		if [[ ${COMP_WORDS[i]} = -?* ]]; then
			[[ ${COMP_WORDS[i]} = $str_filename ]] && continue
			for x in ${!arr_unknown_opts[@]}; do # we don't know bout those, so we leave 'em out
				[[ ${COMP_WORDS[i]} = ${arr_unknown_opts[x]} ]] && continue 2
			done
			# if the user supplied the short form of an option previously, and now requests the long form,
			# remove the corresponding long option, vice versa for short options
			for y in ${!arr_opts[@]}; do # cycle through main options
				set -- ${arr_opts[y]} # $1 = short , $2 = long option
				str_tmp=""
				if [[ ${COMP_WORDS[i]} = $1 ]]; then # we got short version on the cmdline
					str_tmp=$2
				elif [[ ${COMP_WORDS[i]} = $2 ]]; then # we got long version on the cmdline
					str_tmp=$1
				fi
				[[ $str_tmp ]] || continue
				for x in ${!COMPREPLY[@]}; do # compare with compreply
					[[ ${COMPREPLY[x]} != -?* ]] && continue
					if [[ ${COMPREPLY[x]} = $str_tmp ]]; then
						if [[ $_DEBUG_IPSET_COMPL ]]; then
							printf "removing option alias - unsetting COMPREPLY[$x]: %s\n" "${COMPREPLY[x]}"
						fi
						unset COMPREPLY[x]
						break 2
					fi
				done
			done
			for x in ${!COMPREPLY[@]}; do # de-dupe options
				[[ ${COMPREPLY[x]} != -?* ]] && continue
				if [[ ${COMP_WORDS[i]} = ${COMPREPLY[x]} ]]; then
					if [[ $_DEBUG_IPSET_COMPL ]]; then
						printf "removing dupe option - unsetting COMPREPLY[$x]: %s\n" "${COMPREPLY[x]}"
					fi
					unset COMPREPLY[$x]
					break
				fi
			done
		else # dedupe option names (timeout,hashsize, etc), or set names
			if [[ $str_action = @(n|create|add|w|swap) ]]; then
				for x in ${!COMPREPLY[@]}; do
					# continue if reply matches action, could be a set name too
					[[ ${COMPREPLY[x]} = @(-*|$str_action) ]] && continue
					if [[ ${COMP_WORDS[i]} = ${COMPREPLY[x]} ]]; then
						if [[ $_DEBUG_IPSET_COMPL ]]; then
							printf "removing dupe option - unsetting COMPREPLY[$x]: %s\n" "${COMPREPLY[x]}"
						fi
						unset COMPREPLY[$x]
						break
					fi
				done
			fi
		fi
	done
else
	[[ $cur ]] && _ipset_bash_default_compl "$cur"
fi
if [[ $_DEBUG_IPSET_COMPL ]]; then
	printf "COMPREPLY after dedupe:\n"
	printf "<%s>\n" "${COMPREPLY[@]}"
fi
}
complete -F _ipset_complete ipset
