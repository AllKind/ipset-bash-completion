#!/bin/bash

# -----------------------------------------------------------------
# Programmable completion code for ipset (netfilter.org)
#
# https://github.com/AllKind/ipset-bash-completion
# https://sourceforge.net/projects/ipset-bashcompl
# -----------------------------------------------------------------

# Copyright (C) 2013 AllKind (AllKind@fastest.cc)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# -----------------------------------------------------------------
# Tested with ipset versions:
# 6.16.1
# -----------------------------------------------------------------
#
# Put it into ~/.bash_completion or /etc/bash_completion.d/
#
# -----------------------------------------------------------------
#
# Version 1.9
#
# -----------------------------------------------------------------


_ipset_bash_default_compl() { # taken from examples - modified by me
# call with the word to be completed as $1
local t
if [[ $1 == \$\(* ]]; then # command substitution
	t=${1#??}
	COMPREPLY=( $(compgen -c -P '$(' $t) )
elif [[ $1 == \$\{* ]]; then # variables with a leading `${'
	t=${1#??}
	COMPREPLY=( $(compgen -v -P '${' -S '}' $t) )
elif [[ $1 == \$* ]]; then # variables with a leading `$'
	t=${1#?}
	COMPREPLY=( $(compgen -v -P '$' $t ) )
elif [[ "$1" == *@* ]]; then # hostname
	t=${1#*@}
	COMPREPLY=( $( compgen -A hostname $t ) )
elif [[ $1 == *[*?[]* ]]; then # sh-style glob pattern
	COMPREPLY=( $( compgen -G "$1" ) )
# ksh-style extended glob pattern - must be complete
elif shopt -q extglob && [[ $1 == *[?*+\!@]\(*\)* ]]; then
	COMPREPLY=( $( compgen -G "$1" ) )
fi
}

_ipset_get_set_type() {
while read n d; do
	[[ $n = Type: ]] && printf '%s\n' $d && break
done < <(ipset -t list "$1" 2>/dev/null)
}

_ipset_get_members() {
local -i in_list=0 no=0
arr_members=()
if [[ $1 = --names-only ]]; then no=1
	shift
fi
while read -r; do
	[[ $REPLY = Members:* ]] && in_list=1 && continue
	((in_list)) || continue
	if ((no)); then
		arr_members[${#arr_members[@]}]="${REPLY%% *}"
	else
		arr_members[${#arr_members[@]}]="$REPLY"
	fi
done < <(ipset list "$1" 2>/dev/null)
}

_ipset_is_set() {
local -i idx
arr_sets=( $(ipset list -n) )
for idx in ${!arr_sets[@]}; do
	if [[ ${arr_sets[idx]} = $1 ]]; then
		return 0
	fi
done
return 1
}

_ipset_complete() {
shopt -s extglob
local cur prev ips_version str_action str_setname str_filename str_tmp str_order="before after"
local -i i=x=y=got_action=action_index=order_index=0
local -i ignore_errors=use_file=names_only=headers_only=save_format=res_sort=0
local arr_sets=() arr_types=() arr_members=() arr_unknown_opts=() arr_tmp=()
local arr_opts=(
"-\! -exist"
"-o -output"
"-q -quiet"
"-r -resolve"
"-s -sorted"
"-n -name"
"-t -terse"
"-f -file"
)

# ipset version check 6.x upwards (to v?) is supported
ips_version="$(ipset --version)"
ips_version="${ips_version#ipset v}"
ips_version="${ips_version%%.*}"
[[ $ips_version = +([[:digit:]]) ]] || return 1
((ips_version < 6)) && return 1

COMPREPLY=()
COMP_WORDBREAKS=$' \t\n"\'><=;|&(' # TODO: different solution than permanent setting

# expecting _get_comp_words_by_ref() to exist from bash_completion
_get_comp_words_by_ref cur || return
_get_comp_words_by_ref prev || return

#_DEBUG_IPSET_COMPL=Y
if [[ $_DEBUG_IPSET_COMPL ]]; then
	printf "\nCOMP_WORDBREAKS: <%s>\n" "$COMP_WORDBREAKS"
	printf "COMP_LINE: <%s>\n" "$COMP_LINE"
	printf "COMP_TYPE: <%s>\n" "$COMP_TYPE"
	printf "COMP_POINT: <%s>\n" "$COMP_POINT"
	printf "COMP_KEY: <%s>\n" "$COMP_KEY"
	printf "COMP_CWORD: <%s>\n" "$COMP_CWORD"
	printf "COMP_WORDS:\n"
	printf "<%s>\n" "${COMP_WORDS[@]}"
	printf "cur: <%s> prev: <%s>\n" "$cur" "$prev"
fi

# collect information about used options
for ((i=1; i < ${#COMP_WORDS[@]}; i++)); do
	case "${COMP_WORDS[i]}" in
		@(create|n|add|del|test|destroy|x|list|save|restore|flush|rename|e|swap|w|help|version))
			[[ ${COMP_WORDS[i-1]} = @(-f|-file) ]] && continue # there could be a file named like a command
			if ! ((got_action)); then
				if [[ ${COMP_WORDS[i]} = @(create|n|add|del|test|rename|e|swap|w) ]]; then
					for x in ${!arr_opts[@]}; do set -- ${arr_opts[x]}
						[[ ${COMP_WORDS[i+1]} = @($1|$2) ]] && return 0 # sets with names of options 
					done
				fi
				if [[ ${COMP_WORDS[i]} != save ]]; then
					got_action=1 action_index=$i str_action=${COMP_WORDS[i]}
				elif [[ ${COMP_WORDS[i-1]} != @(-o|-output) ]]; then
					got_action=1 action_index=$i str_action=${COMP_WORDS[i]}
				fi
				if [[ $str_action = @(create|n|add|del|test|destroy|x|list|save|restore|flush|rename|e|swap|w) ]]
				then str_setname=${COMP_WORDS[i+1]} # register the set name
				fi
			fi
		;;
		-\!|-exist) [[ ${COMP_WORDS[i-1]} != @(-f|-file) ]] && ignore_errors=1 ;;
		-f|-file) [[ ${COMP_WORDS[i-1]} != @(-f|-file) ]] && use_file=1 str_filename="${COMP_WORDS[i+1]}" ;;
		-n|-name) [[ ${COMP_WORDS[i-1]} != @(-f|-file) ]] && names_only=1 ;;
		-t|-terse) [[ ${COMP_WORDS[i-1]} != @(-f|-file) ]] && headers_only=1 ;;
		-o|-output)
			if [[ ${COMP_WORDS[i-1]} != @(-f|-file) ]]; then save_format=1
				if [[ $prev = @(-o|-output) ]]; then
					save_format=2 # expecting opt-arg
				elif [[ ${COMP_WORDS[i+1]} = save ]]; then
					save_format=3 # no -n/-t with -o save
				fi
			fi
		;;
		-r|-resolve|-s|-sorted) [[ ${COMP_WORDS[i-1]} != @(-f|-file) ]] && res_sort=1 ;;
		-?*)
			if [[ ${COMP_WORDS[i]#-} != @(q|quiet) ]]; then
				if [[ ${COMP_WORDS[i-1]} != @(-f|-file|\>) || ${COMP_WORDS[i+1]} != \< ]]; then # don't include filenames
					arr_unknown_opts[${#arr_unknown_opts[@]}]="${COMP_WORDS[i]}"
				fi
			fi
		;;
		before|after)
			if ((got_action && ! order_index && i == action_index+3)); then
				order_index=$i str_order=""
			fi
		;;
	esac
done

if [[ $_DEBUG_IPSET_COMPL ]]; then
	printf "got_action: <%s>\n" "$got_action"
	printf "\nstr_action: <%s>\n" "$str_action"
	printf "action_index: <%s>\n" "$action_index"
	printf "order_index: <%s>\n" "$order_index"
	printf "str_setname: <%s>\n" "$str_setname"
	printf "str_filename: <%s>\n" "$str_filename"
	printf "save_format: <%s>\n" "$save_format"
	printf "ignore_errors: <%s>\n" "$ignore_errors"
	printf "names_only: <%s>\n" "$names_only"
	printf "headers_only: <%s>\n" "$headers_only"
	printf ": <%s>\n" "$"
	printf ":\n"
	printf "<%s>\n" "${arr_unknown_opts[@]}"
fi

# invalid combination of options
if ((names_only && headers_only)); then
	return 0
elif ((names_only || headers_only)); then
	if ((res_sort || ignore_errors)) || ((save_format == 3)); then
		return 0
	fi
elif ((ignore_errors)); then
	if ((res_sort || save_format)); then
		return 0
	fi
fi

# for help or create, find supported set types and save them into an array
if [[ $str_action = @(help|create|n) ]]; then i=0
	while read -r; do
		[[ $REPLY = "Supported set types:"* ]] && ((!i)) && i=1 && continue
		((i)) || continue
		if [[ $REPLY = *:* ]]; then
			set -- $REPLY
			arr_types[${#arr_types[@]}]="$1"
		fi
	done < <(ipset help)
	for i in ${!arr_types[@]}; do # remove dupe entries
		for ((x=i+1; x < ${#arr_types[@]}; x++)); do
			if [[ ${arr_types[i]} = ${arr_types[x]} ]]; then
				unset arr_types[x]
			fi
		done
	done
fi


case "$cur" in
	-*) # any option is requested
		case "$prev" in
			-)
				if ((got_action)); then
					case "$str_action" in
						create|n) # if users wants to create a set named `-'
							if [[ ${COMP_WORDS[action_index+1]} = - ]]; then
								COMPREPLY=( $( compgen -W '${arr_types[@]}' -- $cur ) )
								return 0
							fi
						;;
					esac
				fi
			;;
		esac
	;;
	*) # not an option
		case "$prev" in
			-) # interactive mode
				if ((got_action)); then
					if _ipset_is_set -; then # check if we have a set named `-'
					if [[ $str_action = @(add|del|test) ]]; then
						str_tmp=$(_ipset_get_set_type "$str_setname")
						if [[ ${COMP_WORDS[action_index+2]} = - ]]; then
							case "$str_tmp" in
								list:*) arr_tmp=()
									COMPREPLY=( $( compgen -W '$str_order timeout' -- $cur ) )
									return 0
								;;
							esac
						elif [[ ${COMP_WORDS[action_index+4]} = @(before|after) && ${COMP_WORDS[action_index+4]} = - ]]; then
							_ipset_get_members --names-only "$str_setname"
							for x in ${!arr_sets[@]}; do
								[[ ${arr_sets[x]} = $str_setname ]] && continue
								for y in ${!arr_members[@]}; do
									[[ ${arr_sets[x]} = ${arr_members[y]} ]] && continue 2
								done
								arr_tmp[${#arr_tmp[@]}]="${arr_sets[x]}"
							done
							COMPREPLY=( $( compgen -W '${arr_tmp[@]}' -- $cur ) )
						fi
					elif [[ $str_action = @(swap|w) && $prev = $str_setname ]]; then
						:
#						COMPREPLY=( $( compgen -W '${arr_sets[*]/$str_setname/}' -- $cur ) )
					elif [[ $str_action != @(create|n) ]]; then
						return 0
#					else
#						return 0
					fi
					fi
				else
					return 0
				fi
			;;
		esac
	;;
esac

case "$cur" in
	-*) # any option is requested
		if ((save_format == 2)); then
			return 0
		fi
		if [[ $str_action = @(create|n) && $prev = $str_setname ]]; then
			return 0 # expecting completion of set types
		fi
		case "$prev" in
			create|n) # -option not expected
				if ((got_action)) && [[ $str_action = $prev ]] && [[ $str_filename != $prev ]]; then
					return 0
				fi
			;;
			add|del|list|test|rename|e|destroy|x|flush|swap|w) # -option not expected
				# check if we have a set beginning with `-'
				if ((got_action)) && [[ $str_action = $prev ]]; then
					if _ipset_is_set "${cur}*"; then
						COMPREPLY=( $( compgen -W '${arr_sets[@]}' -- $cur ) )
					fi
					return 0
				fi
			;;
			\<|\>|-f|-file) # expecting filenames as completion
				compopt -o nospace
				COMPREPLY=( $( compgen -f -- $cur ) )
				return 0
			;;
		esac
		if ((got_action)); then
			case "$str_action" in
				help|version) COMPREPLY=()
					return 0
				;;
				destroy|x|flush) COMPREPLY=( $( compgen -W '-q -quiet' -- $cur ) ) ;;
				restore) COMPREPLY=( $( compgen -W '-\! -exist -f -file -q -quiet' -- $cur ) ) ;;
				save) COMPREPLY=( $( compgen -W '-f -file -q -quiet' -- $cur ) ) ;;
				create|n|add|del)
					if [[ ${COMP_WORDS[action_index+2]} = -* && $prev = $str_setname ]]; then
						if [[ $str_action = @(add|del) && $(_ipset_get_set_type "$str_setname") = list:* ]]; then
							if _ipset_is_set "${cur}*"; then
								COMPREPLY=( $( compgen -W '${arr_sets[@]}' -- $cur ) )
							fi
						fi
						return 0
					fi
					if [[ $str_action = @(create|n) ]]; then
						if [[ $prev = @(timeout|range|maxelem|family|hashsize|size|netmask) ]]; then
							return 0
						fi
					elif [[ $str_action = add ]]; then
						if [[ $prev = @(timeout|before|after) ]]; then
							# TODO: completion on set types starting with a dash
							return 0
						fi
					elif [[ $str_action = del ]]; then
						if [[ $prev = @(before|after) ]]; then
							# TODO: completion on set types starting with a dash
							return 0
						fi
					fi
					for ((i=$action_index+1; i < ${#COMP_WORDS[@]}; i++)); do
						# option not expected, want command value
						if [[ ${COMP_WORDS[i]} = @(timeout|maxelem|hashsize|size) && ${COMP_WORDS[i+1]} != @(+([[:digit:]])|0x+([[:xdigit:]])) ]]
						then return 0 # option argument validation
						elif [[ ${COMP_WORDS[i]} = range && ${COMP_WORDS[i+1]} != *-* ]]
						then return 0 # option argument validation
						elif [[ ${COMP_WORDS[i]} = family && ${COMP_WORDS[i+1]} != inet?(6) ]]
						then return 0 # option argument validation
						fi
					done
					COMPREPLY=( $( compgen -W '-\! -exist -q -quiet' -- $cur ) )
				;;
				list)
					if ((names_only || headers_only)); then
						COMPREPLY=( $( compgen -W '-f -file -o -output -q -quiet' -- $cur ) )
					elif ((res_sort)); then
						COMPREPLY=( $( compgen -W '-f -file -o -output -q -quiet -r -resolve -s -sorted' -- $cur ) )
					elif ((save_format == 1)); then
						COMPREPLY=( $( compgen -W '-f -file -q -quiet -r -resolve -s -sorted -t -terse' -- $cur ) )
					elif ((save_format == 3)); then
						COMPREPLY=( $( compgen -W '-f -file -q -quiet -r -resolve -s -sorted' -- $cur ) )
					else
						COMPREPLY=( $( compgen -W '-f -file -n -name -o -output -q -quiet -r -resolve -s -sorted -t -terse' -- $cur ) )
					fi
				;;
				rename|e|swap|w|test)
					# option not expected, want command value
					if [[ ${COMP_WORDS[action_index+2]} = -* ]]; then
						if [[ $str_action = @(swap|w) && -z ${COMP_WORDS[action_index+3]} ]]; then
							if _ipset_is_set "${cur}*"; then
								COMPREPLY=( $( compgen -W '${arr_sets[@]}' -- $cur ) )
								return 0
							fi
						elif [[ $str_action = test ]]; then
							if [[ $(_ipset_get_set_type "$str_setname") = list:* ]]; then
								if _ipset_is_set "${cur}*"; then
									COMPREPLY=( $( compgen -W '${arr_sets[@]}' -- $cur ) )
									return 0
								fi
							fi
							if [[ $prev = @(before|after) ]]; then
							# TODO: completion on set types starting with a dash
								return 0
							fi
						fi
					fi
					COMPREPLY=( $( compgen -W '-q -quiet' -- $cur ) )
				;;
			esac
		else COMPREPLY=( $( compgen -W '- ${arr_opts[@]}' -- $cur ) )
			if ((names_only || headers_only)) && ((save_format == 1)); then
				COMPREPLY=( $( compgen -W '-f -file -q -quiet' -- $cur ) )
			elif ((names_only || headers_only)); then
				COMPREPLY=( $( compgen -W '-f -file -o -output -q -quiet' -- $cur ) )
			elif ((res_sort)); then
				COMPREPLY=( $( compgen -W '-f -file -o -output -q -quiet -r -resolve -s -sorted' -- $cur ) )
			elif ((save_format == 1)); then
				COMPREPLY=( $( compgen -W '-f -file -q -quiet -r -resolve -s -sorted -t -terse' -- $cur ) )
			elif ((save_format == 3)); then
				COMPREPLY=( $( compgen -W '-f -file -q -quiet -r -resolve -s -sorted' -- $cur ) )
			elif ((ignore_errors)); then
				COMPREPLY=( $( compgen -W '-f -file -q -quiet' -- $cur ) )
			elif ((use_file)); then
				COMPREPLY=( $( compgen -W '-\! -exist -n -name -o -output -q -quiet -r -resolve -s -sorted -t -terse' -- $cur ) )
			fi
		fi
	;;
	\<|\>) # redirection operator
		compopt -o nospace
		COMPREPLY=( $( compgen -f ) ) # no $cur, so completion starts without space after redirection
		return 0
	;;
	\$\{*) # variables with a leading `${'
		COMPREPLY=( $(compgen -v -P '${' -S '}' ${cur#??}) )
		return 0
	;;
	\$*) # variables with a leading `$'
		COMPREPLY=( $(compgen -v -P '$' ${cur#?} ) )
		return 0
	;;
	*) # not an option
		if ((got_action)); then arr_sets=( $(ipset list -n ) )
		else
		COMPREPLY=( $( compgen -W 'create n add del test destroy x list save restore flush rename e swap w help version' -- $cur ) )
		fi
	   	if ((got_action)) && [[ $str_action = $prev ]]; then
			# depend on previous option which should be the action
			# all are terminating conditions
			case "$str_action" in
				create|n|version) COMPREPLY=()
					return 0
				;;
				help)
					COMPREPLY=( $( compgen -W '${arr_types[@]}' -- $cur ) )
					return 0
				;;
				add|del|destroy|x|list|rename|e|swap|w|test)
					COMPREPLY=( $( compgen -W '${arr_sets[@]}' -- $cur ) )
					return 0
				;;
				restore)
					if ! [[ $str_filename ]]; then
						# don't show redirector if we have option -f
						COMPREPLY=( \< )
					fi
					return 0
				;;
				save)
					if [[ $str_action = save ]]; then
						COMPREPLY=( $( compgen -W '${arr_sets[@]}' -- $cur ) ) 
						return 0
					else
						if ((save_format == 3 && ! got_action)); then
							COMPREPLY=( $( compgen -W 'list' -- $cur ) )
							return 0
						fi
					fi
				;;
			esac
		fi
		case "$prev" in # depend on previous option
			-o|-output)
				# make sure it's not a filename named -o or -output
				if [[ $str_filename != $prev ]]; then
					if ((names_only || headers_only)); then
						COMPREPLY=( $( compgen -W 'plain xml' -- $cur ) )
					else
						COMPREPLY=( $( compgen -W 'plain save xml' -- $cur ) )
					fi
					return 0
				fi
			;;
			-f|-file|\<|\>) compopt -o nospace
				COMPREPLY=( $( compgen -f -- $cur ) )
				return 0
			;;
			$str_setname)
				case "$str_action" in
					@(create|n))
						COMPREPLY=( $( compgen -W '${arr_types[@]}' -- $cur ) )
						return 0
					;;
					@(swap|w)) # list two sets
						COMPREPLY=( $( compgen -W '${arr_sets[@]}' -- $cur ) ) 
					;;
					add) # only list sets after the action command
						str_tmp=$(_ipset_get_set_type "$str_setname")
						case "$str_tmp" in
							list:*) arr_tmp=()
								_ipset_get_members --names-only "$str_setname"
								for x in ${!arr_sets[@]}; do
									[[ ${arr_sets[x]} = $str_setname ]] && continue
									for y in ${!arr_members[@]}; do
										[[ ${arr_sets[x]} = ${arr_members[y]} ]] && continue 2
									done
									arr_tmp[${#arr_tmp[@]}]="${arr_sets[x]}"
								done
								COMPREPLY=( $( compgen -W '${arr_tmp[@]}' -- $cur ) )
								return 0
							;;
						esac
					;;
					del|test) COMPREPLY=() # complete members
						_ipset_get_members --names-only "$str_setname"
						COMPREPLY=( $( compgen -W '${arr_members[@]}' -- $cur ) )
						return 0
					;;
				esac
			;;
			*)
			if ((got_action)); then
#				COMPREPLY=( $( compgen -W '${arr_sets[@]}' -- $cur ) )
				case "$str_action" in
					restore) # not a redirecton
					;;
					help)
						if [[ ${COMP_WORDS[action_index+1]} ]]; then 
							COMPREPLY=() # don't go further than showing the set types
							return 0
						fi
					;;
					add)
						str_tmp=$(_ipset_get_set_type "${COMP_WORDS[action_index+1]}")
						if [[ ${COMP_WORDS[action_index+2]} = $prev ]]; then # add options
							case "$str_tmp" in
								hash:*net*)
									COMPREPLY=( $( compgen -W 'timeout nomatch' -- $cur ) )
								;;
								hash:*!(net)*|bitmap:*)
									COMPREPLY=( $( compgen -W 'timeout' -- $cur ) )
								;;
								list:*)
									COMPREPLY=( $( compgen -W '$str_order timeout' -- $cur ) )
								;;
							esac
						else # add options following
							for ((x=$action_index+3; x < ${#COMP_WORDS[@]}; x++)); do # valide option argument values
								[[ ${COMP_WORDS[x]} = timeout && ${COMP_WORDS[x+1]} != @(+([[:digit:]])|0x+([[:xdigit:]])) ]] && return 0
							done
							for ((x=$action_index+2; x < $action_index+6; x++)); do
								if [[ ${COMP_WORDS[x]} = $prev ]]; then
									case "$str_tmp" in
										hash:*net*)
											if [[ $prev != @(-q|-quiet|-\!|-exist|timeout) ]]; then
												COMPREPLY=( $( compgen -W 'timeout nomatch' -- $cur ) )
											fi
										;;
										list:*)
											if [[ $prev = @(before|after) ]]; then
												_ipset_get_members --names-only "$str_setname"
												COMPREPLY=( $( compgen -W '${arr_members[@]}' -- $cur ) )
											elif [[ $prev != @(-q|-quiet|-\!|-exist|timeout) ]]; then
												COMPREPLY=( $( compgen -W '$str_order timeout' -- $cur ) )
											fi
										;;
									esac
								fi
							done
						fi
					;;
					create|n)
						if [[ ${COMP_WORDS[action_index+2]} = $prev ]]; then # create options
							case "$prev" in
								hash:*)
									COMPREPLY=( $( compgen -W 'family hashsize timeout maxelem' -- $cur ) )
								;;
								bitmap:ip)
									COMPREPLY=( $( compgen -W 'range netmask timeout' -- $cur ) )
								;;
								bitmap:!(ip)?*)
									COMPREPLY=( $( compgen -W 'range timeout' -- $cur ) )
								;;
								list:*)
									COMPREPLY=( $( compgen -W 'size timeout' -- $cur ) )
								;;
							esac
						else # create options following
							for ((x=$action_index+3; x < ${#COMP_WORDS[@]}; x++)); do
								case "${COMP_WORDS[x]}" in # validate option argument values
									@(hashsize|timeout|size|maxelem))
										[[ ${COMP_WORDS[x+1]} != @(+([[:digit:]])|0x+([[:xdigit:]])) ]] && return 0
										;;
									family)
										[[ ${COMP_WORDS[x+1]} && ${COMP_WORDS[x+1]} != inet?(6) ]] && return 0
										;;
									range)
										[[ ${COMP_WORDS[x+1]} && ${COMP_WORDS[x+1]} != *-* ]] && return 0
										;;
								esac
							done
							case "${COMP_WORDS[action_index+2]}" in
								hash:*)
									case "$prev" in
										family)
											COMPREPLY=( $( compgen -W 'inet inet6' -- $cur ) )
											return 0
										;;
										*) if [[ $prev != @(-q|-quiet|-\!|-exist|family|hashsize|timeout|maxelem) ]]; then
												COMPREPLY=( $( compgen -W 'family hashsize timeout maxelem' -- $cur ) )
											fi
									esac
								;;
								bitmap:ip)
									if [[ $prev != @(-q|-quiet|-\!|-exist|range|netmask|timeout) ]]; then
										COMPREPLY=( $( compgen -W 'range netmask timeout' -- $cur ) )
									fi
								;;
								bitmap:!(ip)?*)
									if [[ $prev != @(-q|-quiet|-\!|-exist|range|timeout) ]]; then
										COMPREPLY=( $( compgen -W 'range timeout' -- $cur ) )
									fi
								;;
								list:*)
									if [[ $prev != @(-q|-quiet|-\!|-exist|size|timeout) ]]; then
										COMPREPLY=( $( compgen -W 'size timeout' -- $cur ) )
									fi
								;;
							esac
						fi
					;;
					del|test)
						str_tmp=$(_ipset_get_set_type "${COMP_WORDS[action_index+1]}")
						_ipset_get_members --names-only "${COMP_WORDS[action_index+1]}"
						if [[ ${COMP_WORDS[action_index+2]} = $prev ]]; then # add options
							case "$str_tmp" in
								list:*) COMPREPLY=( $( compgen -W '$str_order' -- $cur ) ) ;;
							esac
						else # add options following
							case "$str_tmp" in
								list:*) arr_tmp=()
									if [[ $prev = @(before|after) ]]; then
										case "$prev" in
											before)
												for x in ${!arr_members[@]}; do
													if [[ ${arr_members[x]} = ${COMP_WORDS[action_index+2]} ]]; then
														if [[ ${arr_members[x+1]} ]]; then
															arr_tmp[${#arr_tmp[@]}]=${arr_members[x+1]}
															break
														fi
													fi
												done
												;;
											after)
												for x in ${!arr_members[@]}; do
													if [[ ${arr_members[x]} = ${COMP_WORDS[action_index+2]} ]]; then
														if ((x>0)) && [[ ${arr_members[x-1]} ]]; then
															arr_tmp[${#arr_tmp[@]}]=${arr_members[x-1]}
															break
														fi
													fi
												done
												;;
										esac
										COMPREPLY=( $( compgen -W '${arr_tmp[@]}' -- $cur ) )
										return 0
									fi
								;;
							esac
						fi
					;;
				esac
			else # we don't have the action yet, check options to display appropiate actions
				if ((save_format || names_only || headers_only)); then
					COMPREPLY=( $( compgen -W 'list' -- $cur ) )
					return 0
				elif ((res_sort)); then
					COMPREPLY=( $( compgen -W 'list save' -- $cur ) )
					return 0
				elif ((ignore_errors && use_file)); then
					COMPREPLY=( $( compgen -W 'restore' -- $cur ) )
					return 0
				elif ((ignore_errors)); then
					COMPREPLY=( $( compgen -W 'create n add del restore' -- $cur ) )
					return 0
				elif ((use_file)); then
					COMPREPLY=( $( compgen -W 'list save restore' -- $cur ) )
					return 0
				fi
			fi
			;;
		esac
	;;
esac
if [[ $_DEBUG_IPSET_COMPL ]]; then
	printf "COMPREPLY before dedupe:\n"
	printf "<%s>\n" "${COMPREPLY[@]}"
fi
if ((${#COMPREPLY[@]})); then # post process the reply
	for ((i=1; i < ${#COMP_WORDS[@]}; i++)); do # remove dupe options
		[[ ${COMP_WORDS[i]} ]] || continue
		if [[ ${COMP_WORDS[i]} = -?* ]]; then
			[[ ${COMP_WORDS[i]} = $str_filename ]] && continue
			[[ ${COMP_WORDS[i]} = $str_setname ]] && continue
			for x in ${!arr_unknown_opts[@]}; do # we don't know bout those, so we leave 'em out
				[[ ${COMP_WORDS[i]} = ${arr_unknown_opts[x]} ]] && continue 2
			done
			# if the user supplied the short form of an option previously, and now requests the long form,
			# remove the corresponding long option, vice versa for short options
			for y in ${!arr_opts[@]}; do # cycle through main options
				set -- ${arr_opts[y]} # $1 = short , $2 = long option
				str_tmp=""
				[[ $1 = $cur ]] && continue
				if [[ ${COMP_WORDS[i]} = $1 ]]; then # we got short version on the cmdline
					str_tmp=$2
				elif [[ ${COMP_WORDS[i]} = $2 ]]; then # we got long version on the cmdline
					str_tmp=$1
				fi
				[[ $str_tmp ]] || continue
				for x in ${!COMPREPLY[@]}; do # compare with compreply
					[[ ${COMPREPLY[x]} != -?* ]] && continue
					if [[ ${COMPREPLY[x]} = $str_tmp ]]; then
						if [[ $_DEBUG_IPSET_COMPL ]]; then
							printf "removing option alias - unsetting COMPREPLY[$x]: %s\n" "${COMPREPLY[x]}"
						fi
						unset COMPREPLY[x]
						break 2
					fi
				done
			done
			for x in ${!COMPREPLY[@]}; do # de-dupe options
				[[ ${COMPREPLY[x]} != -?* ]] && continue
				if [[ ${COMP_WORDS[i]} = ${COMPREPLY[x]} && ${COMPREPLY[x]} != $cur ]]; then
					if [[ $_DEBUG_IPSET_COMPL ]]; then
						printf "removing dupe option - unsetting COMPREPLY[$x]: %s\n" "${COMPREPLY[x]}"
					fi
					unset COMPREPLY[$x]
					break
				fi
			done
		else # dedupe option names (timeout,hashsize, etc), or set names
			if [[ $str_action = @(n|create|add|w|swap) ]]; then
				for x in ${!COMPREPLY[@]}; do
					# continue if reply matches action, could be a set name too
					[[ ${COMPREPLY[x]} = $str_action ]] && continue
					if [[ ${COMP_WORDS[i]} = ${COMPREPLY[x]} ]]; then
						if [[ $_DEBUG_IPSET_COMPL ]]; then
							printf "removing dupe option - unsetting COMPREPLY[$x]: %s\n" "${COMPREPLY[x]}"
						fi
						unset COMPREPLY[$x]
						break
					fi
				done
			fi
		fi
	done
else
	[[ $cur ]] && _ipset_bash_default_compl "$cur"
fi
if [[ $_DEBUG_IPSET_COMPL ]]; then
	printf "COMPREPLY after dedupe:\n"
	printf "<%s>\n" "${COMPREPLY[@]}"
fi
}
complete -F _ipset_complete ipset
